%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% CALCOLO CASELLE RAGGIUNGIBILI %%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Regole per caselle raggiungibili direttamente 
% Right
raggiunge(X,Y) :- testa(X1,Y), casella(X,Y,_), not coda(X,Y), X = X1+1.
% Left
raggiunge(X,Y) :- testa(X1,Y), casella(X,Y,_), not coda(X,Y), X = X1-1.
% Up
raggiunge(X,Y) :- testa(X,Y1), casella(X,Y,_), not coda(X,Y), Y = Y1-1.
% Down
raggiunge(X,Y) :- testa(X,Y1), casella(X,Y,_), not coda(X,Y), Y = Y1+1.
% Up Toroidal
raggiunge(X,23) :- testa(X,0), casella(X,23,_), not coda(X,23).
% Down Toroidal
raggiunge(X,0) :- testa(X,23), casella(X,0,_), not coda(X,0).
% Left Toroidal
raggiunge(23,Y) :- testa(0,Y), casella(23,Y,_), not coda(23,Y).
% Right Toroidal
raggiunge(0,Y) :- testa(23,Y), casella(0,Y,_), not coda(0,Y).

% Regole per caselle raggiungibili indirettamente 
raggiunge(X,Y) :- inFinalPath(X,Y1), casella(X,Y,_), Y = Y1+1,not coda(X,Y).
raggiunge(X,Y) :- inFinalPath(X,Y1), casella(X,Y,_), Y = Y1-1,not coda(X,Y).
raggiunge(X,Y) :- inFinalPath(X1,Y), casella(X,Y,_), X = X1+1,not coda(X,Y).
raggiunge(X,Y) :- inFinalPath(X1,Y), casella(X,Y,_), X = X1-1,not coda(X,Y).
% Regole per caselle raggiungibili indirettamente toroidalmente
raggiunge(X,0) :- inFinalPath(X,23), casella(X,0,_),not coda(X,0).
raggiunge(X,23) :- inFinalPath(X,0), casella(X,23,_),not coda(X,23).
raggiunge(0,Y) :- inFinalPath(23,Y), casella(0,Y,_),not coda(0,Y).
raggiunge(23,Y) :- inFinalPath(0,Y), casella(23,Y,_),not coda(23,Y).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% GUESS AND CHECK %%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Guess
inFinalPath(X,Y) | outFinalPath(X,Y) :- raggiunge(X,Y).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% VINCOLI %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Se non c'� la mela dorata, ma c'� la blu, non vorrei non avere quest'ultima nel path.
nonHoMelaDorata :- #count{X,Y: mela(X,Y,4)} = 0.
% Se non c'� ne la mela dorata ne la blu, non vorrei non avere la rossa nel path.
nonHoMelaBlu :- #count{X,Y: mela(X,Y,3)} = 0.
% Una tra le tre mele deve essere sempre raggiungibile nell'inFinalPath.
numeroMele(N) :- N = #count{I: mela(X,Y,I), inFinalPath(X,Y)}.
:- numeroMele(N), N = 0.

% Vincolo su cella nera
:~ inFinalPath(X,Y), casella(X,Y,1). [1@4]

% Se c'� la mela dorata, non vorrei non averla nel path.
:~ mela(X,Y,4), not inFinalPath(X,Y). [1@3]
:~ nonHoMelaDorata, mela(A,B,3), not inFinalPath(A,B). [1@3]
:~ nonHoMelaDorata, nonHoMelaBlu, mela(A,B,2), not inFinalPath(A,B). [1@3]
% Se ci sono pi� Answer Set in cui pago 0@3, allora scendo di livello 
% e scelgo quello in cui ci sono meno inFinalPath(X,Y) possibili.
:~ inFinalPath(X,Y). [1@2, X,Y]

% Vincoli obiettivo multiplo

% QUESTI DUE NON VANNO
% meleInCampo(A) :- A = #count{I: mela(X,Y,I)}.
% :~ meleInCampo(A), A > 1, N = #count{I: mela(X,Y,I), outFinalPath(X,Y)}. [N@1]
% QUI OK
meleFuoriDalPath(N):-#count{I: mela(X,Y,I), outFinalPath(X,Y)}=N.
:~ meleFuoriDalPath(N),N>1. [N@2]


